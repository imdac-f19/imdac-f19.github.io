(window.webpackJsonp=window.webpackJsonp||[]).push([[308],{490:function(e,t,a){"use strict";a.r(t);var i=a(0),n=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"vue-basics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-basics","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue Basics")]),e._v(" "),a("h2",{attrs:{id:"why-vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#why-vue","aria-hidden":"true"}},[e._v("#")]),e._v(" Why Vue")]),e._v(" "),a("p",[e._v("Vue is a JavaScript framework. What is a framework and why do we use it? JavaScript is a very flexible language and its NPM community has tons of packages available for just plug-in use. With great flexibility comes great harm; all the javascript code can be mingled together without any organization or rules. Old version of PHP exemplifies such disorganization.")]),e._v(" "),a("p",[e._v("Over time, developers started to notice there are some common functionalities and libraries that can combine together under software design patterns as open source project, which became projects like AngularJS, Angular, React and Vue.")]),e._v(" "),a("p",[e._v("Vue is a progressive framework that allows you to just plug in one part of your application instead of using it for all as a default. However, consistency is a key in any kind of software development. So such flexible implementation (plugging in only one part) is normally recommended for situations of migrating your code base to Vue implementation); in other words, this flexibility can benefit development without breaking the existing codebase written with another framework or vanilla (plain javascript).")]),e._v(" "),a("h2",{attrs:{id:"vue-architecture"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-architecture","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue Architecture")]),e._v(" "),a("p",[e._v("Vue adopts MVVM (Model-View-View-Model) pattern like other modern frameworks. View is the DOM that data is rendered. Model is the data being manipulated. ViewModel is the group of logics that handles connection between model and view.")]),e._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" vm "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Vue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* options */")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n\nvm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("$el "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// The View ")]),e._v("\nvm"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("$data "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// The Model")]),e._v("\n")])])]),a("p",[e._v("Here, we are creating an instance of Vue class/object, which serves as ViewModel. The DOM and JavaScript objects on DOM are manipulated by Vue. It is completely normal if it is hard to understand in the beginning.")]),e._v(" "),a("h2",{attrs:{id:"vue-lifecycle"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-lifecycle","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue Lifecycle")]),e._v(" "),a("p",[e._v("Lifecycle literally means the lifecycle of a component. Just like any other modern JavaScript framework, Vue offers lifecycle hooks as well, which allows to execute certain logics at a particular stage of a component. As soon as Vue instance is created, Vue will run beforeCreate method, which you can include to execute certain logics. “created”, “beforeMount” and all the others are also methods that get executed during the lifecycle of Vue instance.")]),e._v(" "),a("h2",{attrs:{id:"vue-component-tree"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-component-tree","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue Component Tree")]),e._v(" "),a("p",[e._v("There will be only one Vue instance globally and any other sub-components will have to be registered in the root component. This way of implementation forms a pattern like tree.")]),e._v(" "),a("h2",{attrs:{id:"vue-design-patterns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-design-patterns","aria-hidden":"true"}},[e._v("#")]),e._v(" Vue Design Patterns")]),e._v(" "),a("p",[e._v("In programming world, patterns are very important to encrypt or decrypt. Over time, engineers recognized that they could benefits tremendously by designing software architecture following patterns. They came up with a couple of design patterns. We will discuss only two of them briefly; MVC and MVVM patterns. These patterns are applicable to mobile application development as well.")]),e._v(" "),a("h3",{attrs:{id:"model-view-controller"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#model-view-controller","aria-hidden":"true"}},[e._v("#")]),e._v(" Model-View-Controller")]),e._v(" "),a("p",[e._v("Model is data that is rendered in the View (DOM or Virtual DOM). Controller is to manipulate the data with its own set of logics. An example could be seen in Laravel; "),a("code",[e._v(".blade")]),e._v(" file as a container to hold the view, model is the database table model, and controller is to determine which views to be sent with what model.")]),e._v(" "),a("h3",{attrs:{id:"model-view-view-model"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#model-view-view-model","aria-hidden":"true"}},[e._v("#")]),e._v(" Model-View-View-Model")]),e._v(" "),a("p",[e._v("Almost same as in MVC, Model is the data, View is the DOM (or Virtual DOM), but what is ViewModel? ViewModel is essentially very similar to Controller in MVC pattern. In MVC, developers found it quite challenging to update the View dynamically with more interactivity. For example, let's say, your request to the API takes time and your controller needs to wait until it receives the return object. It becomes a lot more manual to update the view in this case with Controller. Here comes the ViewModel, designed to have a lot tighter connection between View and Model to achieve more enhanced interactivity.")])])}],!1,null,null,null);t.default=n.exports}}]);